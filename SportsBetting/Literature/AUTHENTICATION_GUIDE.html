<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SportsBetting Authentication System - Complete Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 3rem 2rem;
            text-align: center;
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        nav {
            background: #2c3e50;
            padding: 1rem 2rem;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        nav ul {
            list-style: none;
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
        }

        nav a {
            color: white;
            text-decoration: none;
            transition: color 0.3s;
        }

        nav a:hover {
            color: #667eea;
        }

        .content {
            padding: 2rem;
        }

        section {
            margin-bottom: 3rem;
            padding-bottom: 2rem;
            border-bottom: 2px solid #eee;
        }

        section:last-child {
            border-bottom: none;
        }

        h2 {
            color: #667eea;
            font-size: 2rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid #667eea;
        }

        h3 {
            color: #764ba2;
            font-size: 1.5rem;
            margin-top: 2rem;
            margin-bottom: 1rem;
        }

        h4 {
            color: #555;
            font-size: 1.2rem;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }

        p {
            margin-bottom: 1rem;
        }

        .info-box {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 1rem;
            margin: 1rem 0;
        }

        .warning-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 1rem;
            margin: 1rem 0;
        }

        .success-box {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 1rem;
            margin: 1rem 0;
        }

        .danger-box {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
            padding: 1rem;
            margin: 1rem 0;
        }

        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 1.5rem;
            border-radius: 5px;
            overflow-x: auto;
            margin: 1rem 0;
            font-size: 0.9rem;
        }

        code {
            background: #f4f4f4;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #e83e8c;
        }

        pre code {
            background: none;
            padding: 0;
            color: #f8f8f2;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        th, td {
            padding: 0.75rem;
            text-align: left;
            border: 1px solid #ddd;
        }

        th {
            background: #667eea;
            color: white;
            font-weight: bold;
        }

        tr:nth-child(even) {
            background: #f9f9f9;
        }

        .flow-diagram {
            background: #f9f9f9;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 2rem;
            margin: 1.5rem 0;
            font-family: monospace;
        }

        .step {
            background: white;
            border: 2px solid #667eea;
            border-radius: 5px;
            padding: 1rem;
            margin: 0.5rem 0;
            position: relative;
        }

        .step::before {
            content: '↓';
            display: block;
            text-align: center;
            font-size: 1.5rem;
            color: #667eea;
            margin: -2rem 0 0.5rem 0;
        }

        .step:first-child::before {
            content: '';
            margin: 0;
        }

        ul, ol {
            margin-left: 2rem;
            margin-bottom: 1rem;
        }

        li {
            margin-bottom: 0.5rem;
        }

        .endpoint {
            background: #2d2d2d;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            margin: 0.5rem 0;
            font-family: monospace;
        }

        .method-get { color: #61affe; }
        .method-post { color: #49cc90; }
        .method-put { color: #fca130; }
        .method-delete { color: #f93e3e; }

        .toc {
            background: #f9f9f9;
            padding: 1.5rem;
            border-radius: 8px;
            margin-bottom: 2rem;
        }

        .toc h3 {
            margin-top: 0;
        }

        .toc ul {
            list-style: none;
            margin-left: 1rem;
        }

        .toc a {
            color: #667eea;
            text-decoration: none;
        }

        .toc a:hover {
            text-decoration: underline;
        }

        footer {
            background: #2c3e50;
            color: white;
            text-align: center;
            padding: 2rem;
            margin-top: 3rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>SportsBetting Authentication System</h1>
            <p>Complete Guide for Developers</p>
        </header>

        <nav>
            <ul>
                <li><a href="#overview">Overview</a></li>
                <li><a href="#architecture">Architecture</a></li>
                <li><a href="#jwt">JWT Tokens</a></li>
                <li><a href="#endpoints">Endpoints</a></li>
                <li><a href="#security">Security</a></li>
                <li><a href="#database">Database</a></li>
                <li><a href="#code">Code Structure</a></li>
                <li><a href="#testing">Testing</a></li>
            </ul>
        </nav>

        <div class="content">
            <section id="overview">
                <h2>1. Overview</h2>

                <p>This SportsBetting application uses a modern, stateless authentication system based on <strong>JWT (JSON Web Tokens)</strong>. The system is built with ASP.NET Core and implements industry-standard security practices.</p>

                <h3>What You Get</h3>
                <ul>
                    <li><strong>JWT-based authentication</strong> - Stateless, scalable, and secure</li>
                    <li><strong>Refresh tokens</strong> - Long-lived tokens for seamless user experience</li>
                    <li><strong>Password security</strong> - BCrypt hashing with automatic salting</li>
                    <li><strong>Email verification</strong> - Confirm user email addresses</li>
                    <li><strong>Password reset</strong> - Secure "forgot password" functionality</li>
                    <li><strong>Rate limiting</strong> - Protection against brute force attacks</li>
                    <li><strong>Multi-currency support</strong> - Users can choose their preferred currency</li>
                </ul>

                <div class="info-box">
                    <strong>Key Concept:</strong> This is a <strong>stateless</strong> authentication system. The server doesn't store session data. Instead, all user information is encoded in the JWT token itself. This makes the system highly scalable.
                </div>

                <h3>Authentication Flow (High Level)</h3>
                <div class="flow-diagram">
                    <div class="step">
                        <strong>1. Registration</strong><br>
                        User creates account → Server generates email verification token → User data saved to database
                    </div>
                    <div class="step">
                        <strong>2. Email Verification</strong><br>
                        User receives token (currently logged to console) → Submits token to verify email → Account marked as verified
                    </div>
                    <div class="step">
                        <strong>3. Login</strong><br>
                        User submits credentials → Server verifies password → Server generates JWT access token + refresh token → Tokens sent to client
                    </div>
                    <div class="step">
                        <strong>4. Accessing Protected Resources</strong><br>
                        Client includes JWT in Authorization header → Server validates JWT → Request processed if valid
                    </div>
                    <div class="step">
                        <strong>5. Token Refresh</strong><br>
                        Access token expires (15 min) → Client uses refresh token → Server issues new access token + refresh token
                    </div>
                    <div class="step">
                        <strong>6. Logout</strong><br>
                        Client submits refresh token → Server revokes it → User logged out
                    </div>
                </div>
            </section>

            <section id="architecture">
                <h2>2. System Architecture</h2>

                <h3>The Big Picture</h3>
                <p>The authentication system is organized into several layers, following clean architecture principles:</p>

                <pre><code>┌─────────────────────────────────────────────────────────┐
│                    API Layer (Controllers)               │
│  - Receives HTTP requests                                │
│  - Validates input                                       │
│  - Returns HTTP responses                                │
└─────────────────────┬───────────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────────┐
│                 Service Layer (AuthService)              │
│  - Business logic                                        │
│  - Token generation/validation                           │
│  - Password hashing/verification                         │
└─────────────────────┬───────────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────────┐
│               Data Layer (DbContext/Entities)            │
│  - Database operations                                   │
│  - Entity Framework Core                                 │
│  - PostgreSQL database                                   │
└─────────────────────────────────────────────────────────┘</code></pre>

                <h3>Project Structure</h3>
                <table>
                    <tr>
                        <th>Project</th>
                        <th>Purpose</th>
                        <th>Key Files</th>
                    </tr>
                    <tr>
                        <td><strong>SportsBetting.API</strong></td>
                        <td>Web API layer, controllers, services</td>
                        <td>
                            - Controllers/AuthController.cs<br>
                            - Services/AuthService.cs<br>
                            - Services/JwtService.cs<br>
                            - Program.cs
                        </td>
                    </tr>
                    <tr>
                        <td><strong>SportsBetting.Domain</strong></td>
                        <td>Core entities and business rules</td>
                        <td>
                            - Entities/User.cs<br>
                            - Entities/RefreshToken.cs
                        </td>
                    </tr>
                    <tr>
                        <td><strong>SportsBetting.Data</strong></td>
                        <td>Database context and configurations</td>
                        <td>
                            - SportsBettingDbContext.cs<br>
                            - Configurations/*
                        </td>
                    </tr>
                </table>

                <h3>Middleware Pipeline</h3>
                <p>Understanding the middleware order in ASP.NET Core is crucial. Here's what happens to each HTTP request:</p>

                <pre><code>HTTP Request
    ↓
1. CORS Middleware (allows cross-origin requests)
    ↓
2. Rate Limiter (checks request limits)
    ↓
3. Authentication (validates JWT token)
    ↓
4. Authorization (checks if user has permission)
    ↓
5. Controller Action (your endpoint code runs)
    ↓
HTTP Response</code></pre>

                <div class="warning-box">
                    <strong>Important:</strong> The order matters! Rate limiting must come before authentication to prevent attackers from bypassing limits. Authentication must come before authorization to know who the user is before checking permissions.
                </div>
            </section>

            <section id="jwt">
                <h2>3. JWT Tokens Explained</h2>

                <h3>What is a JWT?</h3>
                <p>JWT (JSON Web Token) is a compact, URL-safe token format that contains claims about a user. It consists of three parts separated by dots:</p>

                <pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

│            Header            │             Payload              │           Signature          │</code></pre>

                <h3>Token Anatomy</h3>

                <h4>1. Header</h4>
                <pre><code>{
  "alg": "HS256",  // Algorithm used for signing
  "typ": "JWT"     // Token type
}</code></pre>

                <h4>2. Payload (Claims)</h4>
                <p>Our application includes these claims in every JWT:</p>
                <pre><code>{
  "sub": "ce40595a-26f8-4659-a937-82dee702c2a8",  // User ID (Subject)
  "name": "testuser",                              // Username
  "email": "test@example.com",                     // Email
  "currency": "USD",                               // User's currency preference
  "jti": "2f018bfb-2953-4716-9ad8-c0ec7572ca8e",  // Unique token ID
  "exp": 1678901234,                               // Expiration timestamp
  "iss": "SportsBettingAPI",                       // Issuer
  "aud": "SportsBettingClient"                     // Audience
}</code></pre>

                <h4>3. Signature</h4>
                <p>The signature is created by taking the encoded header + payload and signing it with a secret key. This ensures the token hasn't been tampered with.</p>

                <div class="info-box">
                    <strong>Security Note:</strong> The JWT is <strong>not encrypted</strong> - anyone can decode it and read the claims. However, only someone with the secret key can <strong>create</strong> or <strong>modify</strong> a valid JWT. Never put sensitive data like passwords in a JWT!
                </div>

                <h3>Access Tokens vs Refresh Tokens</h3>

                <table>
                    <tr>
                        <th>Aspect</th>
                        <th>Access Token (JWT)</th>
                        <th>Refresh Token</th>
                    </tr>
                    <tr>
                        <td><strong>Purpose</strong></td>
                        <td>Access protected resources</td>
                        <td>Get new access tokens</td>
                    </tr>
                    <tr>
                        <td><strong>Lifespan</strong></td>
                        <td>15 minutes</td>
                        <td>7 days</td>
                    </tr>
                    <tr>
                        <td><strong>Storage</strong></td>
                        <td>Client-side (memory/localStorage)</td>
                        <td>Database + Client-side</td>
                    </tr>
                    <tr>
                        <td><strong>Can be revoked?</strong></td>
                        <td>No (stateless)</td>
                        <td>Yes (stored in database)</td>
                    </tr>
                    <tr>
                        <td><strong>Used for</strong></td>
                        <td>Every API request</td>
                        <td>Only token refresh endpoint</td>
                    </tr>
                </table>

                <h3>Why Two Types of Tokens?</h3>
                <p>This is a common pattern that balances security and user experience:</p>

                <ul>
                    <li><strong>Short-lived access tokens</strong> reduce the damage if a token is stolen (it expires quickly)</li>
                    <li><strong>Long-lived refresh tokens</strong> mean users don't have to log in constantly</li>
                    <li><strong>Refresh tokens can be revoked</strong> (stored in database), giving you a way to force logout</li>
                    <li><strong>Access tokens are stateless</strong>, so they're fast to validate (no database lookup)</li>
                </ul>

                <h3>JWT Configuration in Our App</h3>
                <p>The JWT settings are in <code>appsettings.json</code>:</p>

                <pre><code>{
  "Jwt": {
    "Secret": "your-very-secure-secret-key-min-32-chars",
    "Issuer": "SportsBettingAPI",
    "Audience": "SportsBettingClient",
    "AccessTokenExpirationMinutes": 15,
    "RefreshTokenExpirationDays": 7
  }
}</code></pre>

                <div class="danger-box">
                    <strong>Production Security:</strong> The JWT secret must be:
                    <ul>
                        <li>At least 32 characters long</li>
                        <li>Randomly generated</li>
                        <li>Stored in environment variables or Azure Key Vault (not in appsettings.json)</li>
                        <li>Never committed to source control</li>
                    </ul>
                </div>

                <h3>How JWT Validation Works</h3>
                <p>When a request comes in with a JWT, here's what happens:</p>

                <div class="flow-diagram">
                    <div class="step">
                        <strong>1. Extract Token</strong><br>
                        ASP.NET Core middleware extracts the JWT from the Authorization header:<br>
                        <code>Authorization: Bearer eyJhbGci...</code>
                    </div>
                    <div class="step">
                        <strong>2. Verify Signature</strong><br>
                        Using the secret key, verify the token hasn't been tampered with
                    </div>
                    <div class="step">
                        <strong>3. Validate Claims</strong><br>
                        Check: Issuer, Audience, Expiration time
                    </div>
                    <div class="step">
                        <strong>4. Extract User Info</strong><br>
                        Claims are loaded into <code>HttpContext.User</code><br>
                        Controllers can access via <code>User.FindFirst(JwtRegisteredClaimNames.Sub)</code>
                    </div>
                    <div class="step">
                        <strong>5. Authorize</strong><br>
                        If token is valid, request proceeds to the controller action
                    </div>
                </div>

                <h3>MapInboundClaims = false</h3>
                <p>This is a critical configuration in <code>Program.cs</code>:</p>

                <pre><code>options.MapInboundClaims = false; // Preserve JWT claim names</code></pre>

                <p><strong>Why this matters:</strong></p>
                <ul>
                    <li>By default, ASP.NET Core maps JWT claim names to .NET ClaimTypes</li>
                    <li>For example, "sub" becomes "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier"</li>
                    <li>Setting this to false preserves the original claim names ("sub", "name", "email")</li>
                    <li>This makes the code cleaner and matches JWT standards</li>
                </ul>
            </section>

            <section id="endpoints">
                <h2>4. API Endpoints</h2>

                <p>All authentication endpoints are under <code>/api/auth</code>. Here's what each one does:</p>

                <h3>Registration & Login</h3>

                <h4>POST /api/auth/register</h4>
                <div class="endpoint">
                    <span class="method-post">POST</span> http://localhost:5192/api/auth/register
                </div>

                <p><strong>Purpose:</strong> Create a new user account</p>
                <p><strong>Rate Limited:</strong> Yes (5 requests/minute per IP)</p>
                <p><strong>Authentication:</strong> None required</p>

                <p><strong>Request Body:</strong></p>
                <pre><code>{
  "username": "alice",
  "email": "alice@example.com",
  "password": "SecurePass123",
  "currency": "USD"
}</code></pre>

                <p><strong>Success Response (201 Created):</strong></p>
                <pre><code>{
  "user": {
    "id": "ce40595a-26f8-4659-a937-82dee702c2a8",
    "username": "alice",
    "email": "alice@example.com",
    "currency": "USD"
  },
  "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refreshToken": "8f7d6e5c4b3a2f1e0d9c8b7a6e5d4c3b2a1f0e9d8c7b6a5e4d3c2b1a0f9e8d7c6"
}</code></pre>

                <p><strong>What happens internally:</strong></p>
                <ol>
                    <li>Validates that username and email are unique</li>
                    <li>Hashes the password using BCrypt (with automatic salt generation)</li>
                    <li>Generates an email verification token (24-hour expiration)</li>
                    <li>Saves user to database with <code>EmailVerified = false</code></li>
                    <li>Logs the verification token to console (in production, this would be emailed)</li>
                    <li>Creates JWT access token and refresh token</li>
                    <li>Saves refresh token to database</li>
                    <li>Returns tokens to client</li>
                </ol>

                <div class="info-box">
                    <strong>Note:</strong> Email verification is currently <strong>optional</strong>. Users can use the app without verifying their email. To make it required, you'd need to add a check in the login endpoint.
                </div>

                <h4>POST /api/auth/login</h4>
                <div class="endpoint">
                    <span class="method-post">POST</span> http://localhost:5192/api/auth/login
                </div>

                <p><strong>Purpose:</strong> Authenticate a user and receive tokens</p>
                <p><strong>Rate Limited:</strong> Yes (5 requests/minute per IP)</p>
                <p><strong>Authentication:</strong> None required</p>

                <p><strong>Request Body:</strong></p>
                <pre><code>{
  "usernameOrEmail": "alice",  // Can be username OR email
  "password": "SecurePass123"
}</code></pre>

                <p><strong>Success Response (200 OK):</strong></p>
                <pre><code>{
  "user": {
    "id": "ce40595a-26f8-4659-a937-82dee702c2a8",
    "username": "alice",
    "email": "alice@example.com",
    "currency": "USD"
  },
  "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refreshToken": "8f7d6e5c4b3a2f1e0d9c8b7a6e5d4c3b2a1f0e9d8c7b6a5e4d3c2b1a0f9e8d7c6"
}</code></pre>

                <p><strong>Error Response (401 Unauthorized):</strong></p>
                <pre><code>{
  "message": "Invalid credentials"
}</code></pre>

                <p><strong>What happens internally:</strong></p>
                <ol>
                    <li>Finds user by username or email</li>
                    <li>Verifies password using BCrypt</li>
                    <li>Checks if user status is "Active" (not "Suspended" or "Closed")</li>
                    <li>Generates new JWT access token</li>
                    <li>Generates new refresh token</li>
                    <li>Saves refresh token to database</li>
                    <li>Returns tokens</li>
                </ol>

                <h3>Token Management</h3>

                <h4>POST /api/auth/refresh</h4>
                <div class="endpoint">
                    <span class="method-post">POST</span> http://localhost:5192/api/auth/refresh
                </div>

                <p><strong>Purpose:</strong> Exchange refresh token for new access token + refresh token</p>
                <p><strong>Rate Limited:</strong> No (uses global limit only)</p>
                <p><strong>Authentication:</strong> None required (refresh token is the authentication)</p>

                <p><strong>Request Body:</strong></p>
                <pre><code>{
  "refreshToken": "8f7d6e5c4b3a2f1e0d9c8b7a6e5d4c3b2a1f0e9d8c7b6a5e4d3c2b1a0f9e8d7c6"
}</code></pre>

                <p><strong>When to use this:</strong></p>
                <p>When your access token expires (after 15 minutes), you'll get a 401 Unauthorized response. Your client should automatically call this endpoint with the refresh token to get a new access token without requiring the user to log in again.</p>

                <p><strong>What happens internally:</strong></p>
                <ol>
                    <li>Looks up refresh token in database</li>
                    <li>Validates it hasn't expired or been revoked</li>
                    <li>Generates new JWT access token</li>
                    <li>Generates new refresh token (token rotation for security)</li>
                    <li>Revokes old refresh token</li>
                    <li>Saves new refresh token to database</li>
                    <li>Returns new tokens</li>
                </ol>

                <div class="info-box">
                    <strong>Refresh Token Rotation:</strong> Each time you use a refresh token, you get a <strong>new</strong> refresh token back, and the old one is revoked. This is a security best practice that limits the damage if a refresh token is stolen.
                </div>

                <h4>POST /api/auth/logout</h4>
                <div class="endpoint">
                    <span class="method-post">POST</span> http://localhost:5192/api/auth/logout
                </div>

                <p><strong>Purpose:</strong> Revoke refresh token (logout)</p>
                <p><strong>Rate Limited:</strong> No</p>
                <p><strong>Authentication:</strong> Required (must include valid JWT in Authorization header)</p>

                <p><strong>Request Headers:</strong></p>
                <pre><code>Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...</code></pre>

                <p><strong>Request Body:</strong></p>
                <pre><code>{
  "refreshToken": "8f7d6e5c4b3a2f1e0d9c8b7a6e5d4c3b2a1f0e9d8c7b6a5e4d3c2b1a0f9e8d7c6"
}</code></pre>

                <p><strong>Success Response (204 No Content):</strong></p>
                <p>(Empty response body)</p>

                <p><strong>What happens internally:</strong></p>
                <ol>
                    <li>Marks the refresh token as revoked in the database</li>
                    <li>Returns 204 No Content</li>
                </ol>

                <div class="warning-box">
                    <strong>Important:</strong> Logging out only revokes the refresh token. The access token will continue to work until it expires (15 minutes). This is a limitation of stateless JWT authentication. If you need immediate logout, you'd need to implement a token blacklist (which adds complexity and database lookups to every request).
                </div>

                <h3>Email Verification</h3>

                <h4>POST /api/auth/verify-email</h4>
                <div class="endpoint">
                    <span class="method-post">POST</span> http://localhost:5192/api/auth/verify-email
                </div>

                <p><strong>Purpose:</strong> Verify user's email address</p>
                <p><strong>Rate Limited:</strong> No</p>
                <p><strong>Authentication:</strong> None required</p>

                <p><strong>Request Body:</strong></p>
                <pre><code>{
  "token": "d4c3b2a1f0e9d8c7b6a5e4d3c2b1a0f9e8d7c6b5a4e3d2c1b0a9f8e7d6c5b4a3e2"
}</code></pre>

                <p><strong>What happens internally:</strong></p>
                <ol>
                    <li>Finds user with matching verification token</li>
                    <li>Checks if token has expired (24-hour window)</li>
                    <li>Sets <code>EmailVerified = true</code></li>
                    <li>Clears the token fields (token can only be used once)</li>
                    <li>Saves to database</li>
                </ol>

                <h4>POST /api/auth/resend-verification</h4>
                <div class="endpoint">
                    <span class="method-post">POST</span> http://localhost:5192/api/auth/resend-verification?email=alice@example.com
                </div>

                <p><strong>Purpose:</strong> Generate and send a new verification email</p>
                <p><strong>What happens internally:</strong></p>
                <ol>
                    <li>Finds user by email</li>
                    <li>Checks if email is already verified (returns error if so)</li>
                    <li>Generates new verification token</li>
                    <li>Updates expiration to 24 hours from now</li>
                    <li>Logs token to console (in production, emails it)</li>
                </ol>

                <h3>Password Reset</h3>

                <h4>POST /api/auth/forgot-password</h4>
                <div class="endpoint">
                    <span class="method-post">POST</span> http://localhost:5192/api/auth/forgot-password
                </div>

                <p><strong>Purpose:</strong> Initiate password reset process</p>
                <p><strong>Rate Limited:</strong> Yes (5 requests/minute per IP)</p>
                <p><strong>Authentication:</strong> None required</p>

                <p><strong>Request Body:</strong></p>
                <pre><code>{
  "email": "alice@example.com"
}</code></pre>

                <p><strong>Success Response (200 OK):</strong></p>
                <pre><code>{
  "message": "Password reset email sent",
  "token": "a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0u1v2w3x4y5z6a7b8c9d0e1f2g3"
}</code></pre>

                <div class="warning-box">
                    <strong>Security Note:</strong> In production, you should NOT return the token in the response. It should only be sent via email. The current implementation returns it for testing purposes.
                </div>

                <p><strong>What happens internally:</strong></p>
                <ol>
                    <li>Finds user by email</li>
                    <li>Generates password reset token (cryptographically random)</li>
                    <li>Sets expiration to 1 hour from now</li>
                    <li>Saves to database</li>
                    <li>Logs token to console (in production, emails it)</li>
                </ol>

                <h4>POST /api/auth/reset-password</h4>
                <div class="endpoint">
                    <span class="method-post">POST</span> http://localhost:5192/api/auth/reset-password
                </div>

                <p><strong>Purpose:</strong> Reset password using the token from forgot-password</p>
                <p><strong>Rate Limited:</strong> No</p>
                <p><strong>Authentication:</strong> None required (token is the authentication)</p>

                <p><strong>Request Body:</strong></p>
                <pre><code>{
  "token": "a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0u1v2w3x4y5z6a7b8c9d0e1f2g3",
  "newPassword": "NewSecurePass456"
}</code></pre>

                <p><strong>What happens internally:</strong></p>
                <ol>
                    <li>Finds user with matching reset token</li>
                    <li>Validates token hasn't expired (1-hour window)</li>
                    <li>Hashes new password with BCrypt</li>
                    <li>Updates password hash</li>
                    <li>Clears reset token (can only be used once)</li>
                    <li>Saves to database</li>
                </ol>

                <div class="success-box">
                    <strong>Security Feature:</strong> Password reset tokens are single-use and expire after 1 hour, providing a secure balance between usability and security.
                </div>

                <h3>User Information</h3>

                <h4>GET /api/auth/me</h4>
                <div class="endpoint">
                    <span class="method-get">GET</span> http://localhost:5192/api/auth/me
                </div>

                <p><strong>Purpose:</strong> Get current authenticated user's information</p>
                <p><strong>Rate Limited:</strong> No (uses global limit only)</p>
                <p><strong>Authentication:</strong> Required</p>

                <p><strong>Request Headers:</strong></p>
                <pre><code>Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...</code></pre>

                <p><strong>Success Response (200 OK):</strong></p>
                <pre><code>{
  "id": "ce40595a-26f8-4659-a937-82dee702c2a8",
  "username": "alice",
  "email": "alice@example.com",
  "currency": "USD"
}</code></pre>

                <p><strong>What happens internally:</strong></p>
                <ol>
                    <li>JWT middleware validates the token</li>
                    <li>Controller extracts claims from <code>HttpContext.User</code></li>
                    <li>Returns user info from the JWT claims (no database lookup needed!)</li>
                </ol>

                <div class="info-box">
                    <strong>Performance Note:</strong> This endpoint is very fast because it reads data from the JWT token without hitting the database. The JWT is the source of truth for user identity.
                </div>
            </section>

            <section id="security">
                <h2>5. Security Features</h2>

                <h3>Password Hashing with BCrypt</h3>

                <p><strong>What is BCrypt?</strong></p>
                <p>BCrypt is a password hashing algorithm specifically designed for securely storing passwords. It has several important features:</p>

                <ul>
                    <li><strong>Adaptive:</strong> Computationally expensive (slow by design) to resist brute force attacks</li>
                    <li><strong>Salted:</strong> Automatically generates a random salt for each password</li>
                    <li><strong>One-way:</strong> Cannot be reversed to get the original password</li>
                </ul>

                <p><strong>How we use it (in User.cs):</strong></p>

                <pre><code>// Hashing a password during registration
public void SetPassword(string password)
{
    // BCrypt automatically generates a salt and hashes the password
    // WorkFactor of 12 means 2^12 = 4096 iterations (balance of security and performance)
    PasswordHash = BCrypt.Net.BCrypt.HashPassword(password, workFactor: 12);
}

// Verifying a password during login
public bool VerifyPassword(string password)
{
    // BCrypt compares the password with the stored hash
    // Returns true if they match, false otherwise
    return BCrypt.Net.BCrypt.Verify(password, PasswordHash);
}</code></pre>

                <div class="danger-box">
                    <strong>Never store passwords in plain text!</strong>
                    <ul>
                        <li>Never log passwords</li>
                        <li>Never return passwords in API responses</li>
                        <li>Never include passwords in JWT tokens</li>
                        <li>Always use a proper hashing algorithm like BCrypt</li>
                    </ul>
                </div>

                <h3>Rate Limiting</h3>

                <p><strong>What is Rate Limiting?</strong></p>
                <p>Rate limiting restricts how many requests a client can make in a given time window. This prevents:</p>
                <ul>
                    <li>Brute force password attacks</li>
                    <li>Credential stuffing attacks</li>
                    <li>Denial of service (DoS) attacks</li>
                    <li>API abuse</li>
                </ul>

                <p><strong>Our Configuration (in Program.cs):</strong></p>

                <pre><code>// Global rate limit - applies to all endpoints
// 100 requests per minute per IP address
options.GlobalLimiter = PartitionedRateLimiter.Create&lt;HttpContext, string&gt;(httpContext =>
    RateLimitPartition.GetFixedWindowLimiter(
        partitionKey: httpContext.Connection.RemoteIpAddress?.ToString() ?? "unknown",
        factory: partition => new FixedWindowRateLimiterOptions
        {
            PermitLimit = 100,
            Window = TimeSpan.FromMinutes(1),
            QueueProcessingOrder = QueueProcessingOrder.OldestFirst,
            QueueLimit = 5
        }));

// Strict rate limit for authentication endpoints
// 5 requests per minute per IP address
options.AddFixedWindowLimiter("auth", options =>
{
    options.PermitLimit = 5;
    options.Window = TimeSpan.FromMinutes(1);
    options.QueueProcessingOrder = QueueProcessingOrder.OldestFirst;
    options.QueueLimit = 0;  // Don't queue - reject immediately
});</code></pre>

                <p><strong>How it works:</strong></p>

                <div class="flow-diagram">
                    <div class="step">
                        <strong>Request #1</strong><br>
                        Allowed (1/5 used)
                    </div>
                    <div class="step">
                        <strong>Request #2, #3, #4, #5</strong><br>
                        Allowed (5/5 used)
                    </div>
                    <div class="step">
                        <strong>Request #6</strong><br>
                        <span style="color: red;">Rejected with 429 Too Many Requests</span>
                    </div>
                    <div class="step">
                        <strong>60 seconds later</strong><br>
                        Counter resets to 0/5
                    </div>
                </div>

                <p><strong>Applying to Endpoints (in AuthController.cs):</strong></p>

                <pre><code>[HttpPost("register")]
[EnableRateLimiting("auth")]  // Uses the "auth" rate limiter (5 req/min)
public async Task&lt;ActionResult&lt;AuthResponse&gt;&gt; Register([FromBody] RegisterRequest request)
{
    // ...
}

[HttpPost("login")]
[EnableRateLimiting("auth")]  // Uses the "auth" rate limiter (5 req/min)
public async Task&lt;ActionResult&lt;AuthResponse&gt;&gt; Login([FromBody] LoginRequest request)
{
    // ...
}</code></pre>

                <p><strong>Error Response when rate limited:</strong></p>
                <pre><code>{
  "message": "Too many requests. Please try again later.",
  "retryAfter": "60 seconds"
}</code></pre>

                <h3>Token Expiration Strategy</h3>

                <table>
                    <tr>
                        <th>Token Type</th>
                        <th>Expiration</th>
                        <th>Rationale</th>
                    </tr>
                    <tr>
                        <td>Access Token (JWT)</td>
                        <td>15 minutes</td>
                        <td>Short lifespan limits damage if stolen. User experience isn't affected because refresh tokens handle renewal automatically.</td>
                    </tr>
                    <tr>
                        <td>Refresh Token</td>
                        <td>7 days</td>
                        <td>Long enough for good UX (user stays logged in for a week), short enough to limit risk if stolen.</td>
                    </tr>
                    <tr>
                        <td>Email Verification Token</td>
                        <td>24 hours</td>
                        <td>Gives user plenty of time to check email, but not so long that an old token could be used maliciously.</td>
                    </tr>
                    <tr>
                        <td>Password Reset Token</td>
                        <td>1 hour</td>
                        <td>Short expiration for security - password reset is urgent and sensitive.</td>
                    </tr>
                </table>

                <h3>Single-Use Tokens</h3>

                <p>Several token types are single-use for security:</p>

                <ul>
                    <li><strong>Refresh tokens:</strong> Each use generates a new token and revokes the old one (refresh token rotation)</li>
                    <li><strong>Email verification tokens:</strong> Cleared from database after successful verification</li>
                    <li><strong>Password reset tokens:</strong> Cleared from database after password is reset</li>
                </ul>

                <p><strong>Why this matters:</strong></p>
                <p>If an attacker somehow obtains a used token (e.g., from server logs, network interception), they can't use it because it's already been consumed and invalidated.</p>

                <h3>Additional Security Measures</h3>

                <h4>User Status Validation</h4>
                <p>The <code>UserStatus</code> enum allows for account management:</p>

                <pre><code>public enum UserStatus
{
    Active = 0,    // Can log in and use the app
    Suspended = 1, // Temporarily blocked
    Closed = 2     // Permanently deactivated
}</code></pre>

                <p>During login, we check: <code>if (user.Status != UserStatus.Active)</code></p>

                <h4>ClockSkew = Zero</h4>
                <p>In the JWT configuration:</p>

                <pre><code>ClockSkew = TimeSpan.Zero  // No tolerance for token expiration</code></pre>

                <p>By default, ASP.NET Core allows a 5-minute grace period for expired tokens (to account for clock differences between servers). We've disabled this for stricter security. Tokens expire exactly at their expiration time.</p>

                <h4>HTTPS Redirect</h4>
                <p>In Program.cs: <code>app.UseHttpsRedirection();</code></p>
                <p>All HTTP traffic is automatically redirected to HTTPS, ensuring tokens are transmitted over encrypted connections.</p>
            </section>

            <section id="database">
                <h2>6. Database Schema</h2>

                <h3>Users Table</h3>

                <p>The <code>Users</code> table stores all user account information:</p>

                <table>
                    <tr>
                        <th>Column</th>
                        <th>Type</th>
                        <th>Purpose</th>
                    </tr>
                    <tr>
                        <td>Id</td>
                        <td>UUID (Guid)</td>
                        <td>Primary key, unique identifier</td>
                    </tr>
                    <tr>
                        <td>Username</td>
                        <td>varchar(50)</td>
                        <td>Unique username</td>
                    </tr>
                    <tr>
                        <td>Email</td>
                        <td>varchar(255)</td>
                        <td>Unique email address</td>
                    </tr>
                    <tr>
                        <td>PasswordHash</td>
                        <td>varchar(255)</td>
                        <td>BCrypt hashed password</td>
                    </tr>
                    <tr>
                        <td>Status</td>
                        <td>int</td>
                        <td>0=Active, 1=Suspended, 2=Closed</td>
                    </tr>
                    <tr>
                        <td>Currency</td>
                        <td>varchar(3)</td>
                        <td>User's preferred currency (USD, EUR, etc.)</td>
                    </tr>
                    <tr>
                        <td>EmailVerified</td>
                        <td>boolean</td>
                        <td>Whether email has been verified</td>
                    </tr>
                    <tr>
                        <td>EmailVerificationToken</td>
                        <td>varchar(255)</td>
                        <td>Token for email verification (nullable)</td>
                    </tr>
                    <tr>
                        <td>EmailVerificationTokenExpires</td>
                        <td>timestamp</td>
                        <td>When verification token expires (nullable)</td>
                    </tr>
                    <tr>
                        <td>PasswordResetToken</td>
                        <td>varchar(255)</td>
                        <td>Token for password reset (nullable)</td>
                    </tr>
                    <tr>
                        <td>PasswordResetTokenExpires</td>
                        <td>timestamp</td>
                        <td>When reset token expires (nullable)</td>
                    </tr>
                    <tr>
                        <td>CreatedAt</td>
                        <td>timestamp</td>
                        <td>When account was created</td>
                    </tr>
                    <tr>
                        <td>UpdatedAt</td>
                        <td>timestamp</td>
                        <td>Last modification time</td>
                    </tr>
                </table>

                <h3>RefreshTokens Table</h3>

                <p>The <code>RefreshTokens</code> table stores all issued refresh tokens:</p>

                <table>
                    <tr>
                        <th>Column</th>
                        <th>Type</th>
                        <th>Purpose</th>
                    </tr>
                    <tr>
                        <td>Id</td>
                        <td>UUID (Guid)</td>
                        <td>Primary key</td>
                    </tr>
                    <tr>
                        <td>UserId</td>
                        <td>UUID (Guid)</td>
                        <td>Foreign key to Users table</td>
                    </tr>
                    <tr>
                        <td>Token</td>
                        <td>varchar(255)</td>
                        <td>The actual refresh token (random string)</td>
                    </tr>
                    <tr>
                        <td>ExpiresAt</td>
                        <td>timestamp</td>
                        <td>When token expires (7 days from creation)</td>
                    </tr>
                    <tr>
                        <td>CreatedAt</td>
                        <td>timestamp</td>
                        <td>When token was created</td>
                    </tr>
                    <tr>
                        <td>RevokedAt</td>
                        <td>timestamp</td>
                        <td>When token was revoked (nullable)</td>
                    </tr>
                    <tr>
                        <td>ReplacedByToken</td>
                        <td>varchar(255)</td>
                        <td>If rotated, the new token that replaced this (nullable)</td>
                    </tr>
                </table>

                <h3>Entity Relationships</h3>

                <pre><code>┌─────────────────────────┐
│         Users           │
│─────────────────────────│
│ Id (PK)                 │
│ Username (unique)       │
│ Email (unique)          │
│ PasswordHash            │
│ ...                     │
└────────┬────────────────┘
         │
         │ 1:N
         │
         ▼
┌─────────────────────────┐
│    RefreshTokens        │
│─────────────────────────│
│ Id (PK)                 │
│ UserId (FK)             │
│ Token                   │
│ ExpiresAt               │
│ RevokedAt               │
│ ...                     │
└─────────────────────────┘</code></pre>

                <p><strong>Relationship:</strong> One user can have many refresh tokens (one-to-many). This is normal because:</p>
                <ul>
                    <li>User might be logged in on multiple devices</li>
                    <li>Old revoked tokens are kept for audit purposes</li>
                    <li>Each token refresh creates a new token</li>
                </ul>

                <h3>Database Configuration (Entity Framework)</h3>

                <p>Entity Framework Core handles the database mapping. Key configuration files:</p>

                <h4>SportsBettingDbContext.cs</h4>
                <pre><code>protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    base.OnModelCreating(modelBuilder);

    // Apply all entity configurations
    modelBuilder.ApplyConfigurationsFromAssembly(typeof(SportsBettingDbContext).Assembly);
}</code></pre>

                <h4>Configurations/UserConfiguration.cs</h4>
                <pre><code>public void Configure(EntityTypeBuilder&lt;User&gt; builder)
{
    builder.ToTable("Users");

    builder.HasKey(u => u.Id);

    // Username must be unique
    builder.HasIndex(u => u.Username)
        .IsUnique();

    // Email must be unique
    builder.HasIndex(u => u.Email)
        .IsUnique();

    builder.Property(u => u.Username)
        .IsRequired()
        .HasMaxLength(50);

    builder.Property(u => u.Email)
        .IsRequired()
        .HasMaxLength(255);

    // ... more configuration
}</code></pre>

                <h3>Migrations</h3>

                <p>The database schema is version-controlled through migrations:</p>

                <ul>
                    <li><code>20251115014637_AddEmailVerification.cs</code> - Added email verification fields</li>
                    <li><code>20251115024606_AddPasswordReset.cs</code> - Added password reset fields</li>
                </ul>

                <p><strong>To create a new migration:</strong></p>
                <pre><code>dotnet ef migrations add MigrationName --project SportsBetting.Data</code></pre>

                <p><strong>To apply migrations to database:</strong></p>
                <pre><code>dotnet ef database update --project SportsBetting.Data</code></pre>
            </section>

            <section id="code">
                <h2>7. Code Structure Deep Dive</h2>

                <h3>User Entity (SportsBetting.Domain/Entities/User.cs)</h3>

                <p>This is the core domain entity representing a user. Key methods:</p>

                <h4>Password Management</h4>
                <pre><code>public void SetPassword(string password)
{
    PasswordHash = BCrypt.Net.BCrypt.HashPassword(password, workFactor: 12);
}

public bool VerifyPassword(string password)
{
    return BCrypt.Net.BCrypt.Verify(password, PasswordHash);
}</code></pre>

                <h4>Email Verification Token Generation</h4>
                <pre><code>public string GenerateEmailVerificationToken()
{
    // Generate a random 64-character hexadecimal token
    var token = Convert.ToHexString(RandomNumberGenerator.GetBytes(32));
    EmailVerificationToken = token;
    EmailVerificationTokenExpires = DateTime.UtcNow.AddHours(24);
    return token;
}

public bool VerifyEmailToken(string token)
{
    // Check if token matches and hasn't expired
    return EmailVerificationToken == token
        && EmailVerificationTokenExpires.HasValue
        && EmailVerificationTokenExpires.Value > DateTime.UtcNow;
}</code></pre>

                <h4>Password Reset Token Generation</h4>
                <pre><code>public string GeneratePasswordResetToken()
{
    var token = Convert.ToHexString(RandomNumberGenerator.GetBytes(32));
    PasswordResetToken = token;
    PasswordResetTokenExpires = DateTime.UtcNow.AddHours(1); // Only 1 hour!
    return token;
}

public bool VerifyPasswordResetToken(string token)
{
    return PasswordResetToken == token
        && PasswordResetTokenExpires.HasValue
        && PasswordResetTokenExpires.Value > DateTime.UtcNow;
}</code></pre>

                <div class="info-box">
                    <strong>Security Note:</strong> Tokens are generated using <code>RandomNumberGenerator.GetBytes()</code>, which is cryptographically secure (unlike <code>Random</code> class). The 32 bytes = 256 bits of entropy, making tokens virtually impossible to guess.
                </div>

                <h3>JwtService (SportsBetting.API/Services/JwtService.cs)</h3>

                <p>This service handles JWT creation:</p>

                <pre><code>public string GenerateAccessToken(User user)
{
    var claims = new[]
    {
        new Claim(JwtRegisteredClaimNames.Sub, user.Id.ToString()),
        new Claim(JwtRegisteredClaimNames.Name, user.Username),
        new Claim(JwtRegisteredClaimNames.Email, user.Email),
        new Claim("currency", user.Currency),
        new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
    };

    var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_jwtSecret));
    var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

    var token = new JwtSecurityToken(
        issuer: _jwtIssuer,
        audience: _jwtAudience,
        claims: claims,
        expires: DateTime.UtcNow.AddMinutes(_accessTokenExpiration),
        signingCredentials: creds
    );

    return new JwtSecurityTokenHandler().WriteToken(token);
}</code></pre>

                <p><strong>Breaking it down:</strong></p>

                <ol>
                    <li><strong>Claims:</strong> Information about the user encoded in the token</li>
                    <li><strong>Key:</strong> The secret key used to sign the token</li>
                    <li><strong>SigningCredentials:</strong> Specifies HMAC-SHA256 algorithm</li>
                    <li><strong>JwtSecurityToken:</strong> Constructs the token with all components</li>
                    <li><strong>WriteToken:</strong> Serializes to the final JWT string</li>
                </ol>

                <h3>AuthService (SportsBetting.API/Services/AuthService.cs)</h3>

                <p>This is where the main authentication business logic lives. Let's examine the key methods:</p>

                <h4>RegisterAsync</h4>
                <pre><code>public async Task&lt;AuthResponse&gt; RegisterAsync(RegisterRequest request)
{
    // 1. Check if username already exists
    if (await _context.Users.AnyAsync(u => u.Username == request.Username))
        throw new InvalidOperationException("Username already exists");

    // 2. Check if email already exists
    if (await _context.Users.AnyAsync(u => u.Email == request.Email))
        throw new InvalidOperationException("Email already exists");

    // 3. Create new user entity
    var user = new User
    {
        Id = Guid.NewGuid(),
        Username = request.Username,
        Email = request.Email,
        Currency = request.Currency,
        Status = UserStatus.Active,
        EmailVerified = false,
        CreatedAt = DateTime.UtcNow,
        UpdatedAt = DateTime.UtcNow
    };

    // 4. Hash the password
    user.SetPassword(request.Password);

    // 5. Generate email verification token
    var verificationToken = user.GenerateEmailVerificationToken();
    _logger.LogInformation("Email verification token for {Email}: {Token}",
        user.Email, verificationToken);

    // 6. Save to database
    _context.Users.Add(user);
    await _context.SaveChangesAsync();

    // 7. Generate JWT tokens
    var accessToken = _jwtService.GenerateAccessToken(user);
    var refreshToken = await CreateRefreshTokenAsync(user.Id);

    // 8. Return response
    return new AuthResponse
    {
        User = new UserInfo { Id = user.Id, Username = user.Username,
                              Email = user.Email, Currency = user.Currency },
        AccessToken = accessToken,
        RefreshToken = refreshToken
    };
}</code></pre>

                <h4>LoginAsync</h4>
                <pre><code>public async Task&lt;AuthResponse&gt; LoginAsync(LoginRequest request)
{
    // 1. Find user by username or email
    var user = await _context.Users
        .FirstOrDefaultAsync(u => u.Username == request.UsernameOrEmail
                               || u.Email == request.UsernameOrEmail);

    // 2. Verify user exists and password is correct
    if (user == null || !user.VerifyPassword(request.Password))
        throw new UnauthorizedAccessException("Invalid credentials");

    // 3. Check user status
    if (user.Status != UserStatus.Active)
        throw new UnauthorizedAccessException("Account is not active");

    // 4. Generate tokens
    var accessToken = _jwtService.GenerateAccessToken(user);
    var refreshToken = await CreateRefreshTokenAsync(user.Id);

    // 5. Return response
    return new AuthResponse
    {
        User = new UserInfo { Id = user.Id, Username = user.Username,
                              Email = user.Email, Currency = user.Currency },
        AccessToken = accessToken,
        RefreshToken = refreshToken
    };
}</code></pre>

                <div class="warning-box">
                    <strong>Security Best Practice:</strong> Notice we return the same error message whether the user doesn't exist or the password is wrong ("Invalid credentials"). This prevents attackers from enumerating valid usernames.
                </div>

                <h4>RefreshTokenAsync</h4>
                <pre><code>public async Task&lt;AuthResponse&gt; RefreshTokenAsync(string refreshToken)
{
    // 1. Find the refresh token in database
    var token = await _context.RefreshTokens
        .Include(rt => rt.User)
        .FirstOrDefaultAsync(rt => rt.Token == refreshToken);

    // 2. Validate token exists and is still valid
    if (token == null || token.RevokedAt != null || token.ExpiresAt < DateTime.UtcNow)
        throw new UnauthorizedAccessException("Invalid refresh token");

    // 3. Revoke old token (refresh token rotation)
    token.RevokedAt = DateTime.UtcNow;

    // 4. Generate new tokens
    var accessToken = _jwtService.GenerateAccessToken(token.User);
    var newRefreshToken = await CreateRefreshTokenAsync(token.UserId);

    // 5. Link old token to new token (for audit trail)
    token.ReplacedByToken = newRefreshToken;

    await _context.SaveChangesAsync();

    // 6. Return new tokens
    return new AuthResponse
    {
        User = new UserInfo { Id = token.User.Id, Username = token.User.Username,
                              Email = token.User.Email, Currency = token.User.Currency },
        AccessToken = accessToken,
        RefreshToken = newRefreshToken
    };
}</code></pre>

                <h3>AuthController (SportsBetting.API/Controllers/AuthController.cs)</h3>

                <p>The controller is thin - it delegates to the service layer:</p>

                <pre><code>[HttpPost("login")]
[AllowAnonymous]
[EnableRateLimiting("auth")]
public async Task&lt;ActionResult&lt;AuthResponse&gt;&gt; Login([FromBody] LoginRequest request)
{
    try
    {
        var response = await _authService.LoginAsync(request);
        return Ok(response);
    }
    catch (UnauthorizedAccessException ex)
    {
        _logger.LogWarning("Login failed: {Message}", ex.Message);
        return Unauthorized(new { message = ex.Message });
    }
}</code></pre>

                <p><strong>Controller Responsibilities:</strong></p>
                <ul>
                    <li>HTTP routing (<code>[HttpPost("login")]</code>)</li>
                    <li>Authentication requirements (<code>[AllowAnonymous]</code> or <code>[Authorize]</code>)</li>
                    <li>Rate limiting (<code>[EnableRateLimiting("auth")]</code>)</li>
                    <li>Exception handling (try/catch)</li>
                    <li>HTTP status codes (<code>Ok()</code>, <code>Unauthorized()</code>, etc.)</li>
                    <li>Logging</li>
                </ul>

                <div class="success-box">
                    <strong>Best Practice:</strong> Keep controllers thin. Business logic belongs in service classes, not controllers. This makes code easier to test and maintain.
                </div>
            </section>

            <section id="testing">
                <h2>8. Testing the Authentication System</h2>

                <h3>Running the Application</h3>

                <p><strong>1. Ensure PostgreSQL is running:</strong></p>
                <pre><code>brew services list
# Should show postgresql@16 as "started"</code></pre>

                <p><strong>2. Apply database migrations:</strong></p>
                <pre><code>cd SportsBetting.Data
dotnet ef database update</code></pre>

                <p><strong>3. Run the API:</strong></p>
                <pre><code>cd ../SportsBetting.API
dotnet run</code></pre>

                <p>The API will start on <code>http://localhost:5192</code></p>

                <h3>Testing with Swagger</h3>

                <p>Navigate to <code>http://localhost:5192</code> in your browser. You'll see the Swagger UI with all endpoints documented.</p>

                <p><strong>To test a protected endpoint:</strong></p>
                <ol>
                    <li>Use the <code>/api/auth/register</code> or <code>/api/auth/login</code> endpoint to get a JWT</li>
                    <li>Copy the <code>accessToken</code> from the response</li>
                    <li>Click the "Authorize" button at the top of Swagger</li>
                    <li>Enter: <code>Bearer your-jwt-token-here</code></li>
                    <li>Click "Authorize"</li>
                    <li>Now you can test protected endpoints like <code>/api/auth/me</code></li>
                </ol>

                <h3>Testing with curl</h3>

                <h4>Register a User</h4>
                <pre><code>curl -X POST http://localhost:5192/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "username": "alice",
    "email": "alice@example.com",
    "password": "SecurePass123",
    "currency": "USD"
  }'</code></pre>

                <h4>Login</h4>
                <pre><code>curl -X POST http://localhost:5192/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "usernameOrEmail": "alice",
    "password": "SecurePass123"
  }'</code></pre>

                <h4>Access Protected Endpoint</h4>
                <pre><code>TOKEN="your-jwt-token-here"

curl -X GET http://localhost:5192/api/auth/me \
  -H "Authorization: Bearer $TOKEN"</code></pre>

                <h3>Python Test Scripts</h3>

                <p>There are several test scripts in <code>/tmp</code>:</p>

                <ul>
                    <li><code>test_10_concurrent_users.py</code> - Tests 10 concurrent users with rate limiting</li>
                    <li><code>test_rate_limiting.py</code> - Tests rate limiting enforcement</li>
                    <li><code>test_password_reset.py</code> - Tests password reset flow</li>
                    <li><code>test_email_verification.py</code> - Tests email verification</li>
                </ul>

                <p><strong>To run a test:</strong></p>
                <pre><code>python3 /tmp/test_10_concurrent_users.py</code></pre>

                <h3>Common Test Scenarios</h3>

                <h4>1. Complete Registration → Verification → Login Flow</h4>
                <pre><code># 1. Register
POST /api/auth/register
{
  "username": "bob",
  "email": "bob@example.com",
  "password": "BobPass123",
  "currency": "EUR"
}

# 2. Check console logs for verification token
# Look for: "Email verification token for bob@example.com: abc123..."

# 3. Verify email
POST /api/auth/verify-email
{
  "token": "abc123..."
}

# 4. Login
POST /api/auth/login
{
  "usernameOrEmail": "bob",
  "password": "BobPass123"
}</code></pre>

                <h4>2. Password Reset Flow</h4>
                <pre><code># 1. Request password reset
POST /api/auth/forgot-password
{
  "email": "bob@example.com"
}

# 2. Check console logs for reset token

# 3. Reset password
POST /api/auth/reset-password
{
  "token": "xyz789...",
  "newPassword": "NewBobPass456"
}

# 4. Login with new password
POST /api/auth/login
{
  "usernameOrEmail": "bob",
  "password": "NewBobPass456"
}</code></pre>

                <h4>3. Token Refresh Flow</h4>
                <pre><code># 1. Login
response = POST /api/auth/login { ... }
# Save both accessToken and refreshToken

# 2. Use access token for 15 minutes
GET /api/auth/me
Authorization: Bearer {accessToken}

# 3. After access token expires (15 min), refresh it
POST /api/auth/refresh
{
  "refreshToken": "{refreshToken}"
}

# You'll get new access token AND new refresh token</code></pre>

                <h4>4. Testing Rate Limiting</h4>
                <pre><code># Try to login 6 times rapidly (limit is 5/minute)
for i in {1..6}; do
  curl -X POST http://localhost:5192/api/auth/login \
    -H "Content-Type: application/json" \
    -d '{"usernameOrEmail":"wrong","password":"wrong"}'
  echo ""
done

# 6th request should return 429 Too Many Requests</code></pre>

                <h3>Troubleshooting Common Issues</h3>

                <table>
                    <tr>
                        <th>Error</th>
                        <th>Cause</th>
                        <th>Solution</th>
                    </tr>
                    <tr>
                        <td>401 Unauthorized on /api/auth/me</td>
                        <td>Invalid or expired JWT</td>
                        <td>Get a new token via login or refresh</td>
                    </tr>
                    <tr>
                        <td>429 Too Many Requests</td>
                        <td>Rate limit exceeded</td>
                        <td>Wait 60 seconds for window to reset</td>
                    </tr>
                    <tr>
                        <td>"Username already exists"</td>
                        <td>User already registered</td>
                        <td>Use a different username or login instead</td>
                    </tr>
                    <tr>
                        <td>"Invalid credentials"</td>
                        <td>Wrong username/email or password</td>
                        <td>Check spelling and password</td>
                    </tr>
                    <tr>
                        <td>"Invalid refresh token"</td>
                        <td>Token expired, revoked, or doesn't exist</td>
                        <td>Login again to get new tokens</td>
                    </tr>
                    <tr>
                        <td>Database connection error</td>
                        <td>PostgreSQL not running</td>
                        <td>brew services start postgresql@16</td>
                    </tr>
                </table>
            </section>

            <section id="advanced">
                <h2>9. Advanced Topics</h2>

                <h3>Production Deployment Checklist</h3>

                <div class="danger-box">
                    <strong>Critical Security Items:</strong>
                    <ol>
                        <li><strong>JWT Secret:</strong> Use environment variable, minimum 32 characters, cryptographically random</li>
                        <li><strong>Email Service:</strong> Integrate SendGrid, AWS SES, or similar for actual email sending</li>
                        <li><strong>HTTPS Only:</strong> Enforce HTTPS in production, get SSL certificate</li>
                        <li><strong>Database Credentials:</strong> Use environment variables, never commit to Git</li>
                        <li><strong>CORS Policy:</strong> Replace "AllowAll" with specific origins</li>
                        <li><strong>Rate Limiting:</strong> Tune limits based on actual usage patterns</li>
                        <li><strong>Logging:</strong> Never log passwords or tokens</li>
                        <li><strong>Password Policy:</strong> Enforce minimum strength (currently not enforced)</li>
                    </ol>
                </div>

                <h3>Email Service Integration</h3>

                <p>Currently, email verification and password reset tokens are logged to console. In production, you need an email service:</p>

                <pre><code>// Create an IEmailService interface
public interface IEmailService
{
    Task SendEmailVerificationAsync(string email, string token);
    Task SendPasswordResetAsync(string email, string token);
}

// Implement with SendGrid
public class SendGridEmailService : IEmailService
{
    private readonly ISendGridClient _client;
    private readonly string _fromEmail;

    public async Task SendEmailVerificationAsync(string email, string token)
    {
        var verificationLink = $"https://yourdomain.com/verify?token={token}";
        var msg = new SendGridMessage
        {
            From = new EmailAddress(_fromEmail, "SportsBetting"),
            Subject = "Verify Your Email",
            PlainTextContent = $"Click to verify: {verificationLink}",
            HtmlContent = $"&lt;a href='{verificationLink}'&gt;Verify Email&lt;/a&gt;"
        };
        msg.AddTo(email);
        await _client.SendEmailAsync(msg);
    }
}</code></pre>

                <h3>Making Email Verification Required</h3>

                <p>To enforce email verification before allowing login:</p>

                <pre><code>// In AuthService.LoginAsync, add this check:
if (!user.EmailVerified)
{
    throw new UnauthorizedAccessException(
        "Please verify your email address before logging in");
}</code></pre>

                <h3>Implementing Password Strength Validation</h3>

                <p>Add validation to enforce strong passwords:</p>

                <pre><code>public class PasswordValidator
{
    public static (bool isValid, string message) Validate(string password)
    {
        if (password.Length < 8)
            return (false, "Password must be at least 8 characters");

        if (!password.Any(char.IsUpper))
            return (false, "Password must contain at least one uppercase letter");

        if (!password.Any(char.IsLower))
            return (false, "Password must contain at least one lowercase letter");

        if (!password.Any(char.IsDigit))
            return (false, "Password must contain at least one number");

        return (true, "");
    }
}</code></pre>

                <h3>Adding Two-Factor Authentication (2FA)</h3>

                <p>To add 2FA support, you would need:</p>

                <ol>
                    <li>Add <code>TwoFactorEnabled</code> and <code>TwoFactorSecret</code> fields to User entity</li>
                    <li>Use a library like <code>OtpNet</code> to generate/verify TOTP codes</li>
                    <li>Add a setup endpoint to generate QR code for authenticator apps</li>
                    <li>Modify login flow to require 2FA code after password verification</li>
                    <li>Provide backup codes for account recovery</li>
                </ol>

                <h3>Monitoring and Logging</h3>

                <p>Important events to log:</p>

                <ul>
                    <li>Successful registrations</li>
                    <li>Successful logins (with IP address)</li>
                    <li>Failed login attempts (for security monitoring)</li>
                    <li>Password resets</li>
                    <li>Token refreshes</li>
                    <li>Rate limit violations</li>
                </ul>

                <p>Consider integrating:</p>
                <ul>
                    <li><strong>Application Insights</strong> (Azure) for telemetry</li>
                    <li><strong>Sentry</strong> for error tracking</li>
                    <li><strong>ELK Stack</strong> for log aggregation</li>
                </ul>

                <h3>Scaling Considerations</h3>

                <p><strong>Stateless JWTs are horizontally scalable:</strong></p>
                <ul>
                    <li>No session storage needed</li>
                    <li>Can run multiple API instances behind a load balancer</li>
                    <li>Each instance can validate JWTs independently</li>
                </ul>

                <p><strong>Database considerations:</strong></p>
                <ul>
                    <li>Refresh tokens table will grow over time - consider cleanup job for expired/revoked tokens</li>
                    <li>Add database indexes on frequently queried fields (already done for Username/Email)</li>
                    <li>Consider read replicas for high-traffic scenarios</li>
                </ul>

                <p><strong>Rate limiting with multiple instances:</strong></p>
                <ul>
                    <li>Current implementation uses in-memory rate limiting (per instance)</li>
                    <li>For multi-instance deployment, use distributed rate limiting (Redis-based)</li>
                </ul>
            </section>

            <section id="glossary">
                <h2>10. Glossary</h2>

                <table>
                    <tr>
                        <th>Term</th>
                        <th>Definition</th>
                    </tr>
                    <tr>
                        <td><strong>JWT (JSON Web Token)</strong></td>
                        <td>A compact, self-contained token format for securely transmitting information between parties as a JSON object</td>
                    </tr>
                    <tr>
                        <td><strong>Claims</strong></td>
                        <td>Pieces of information asserted about a subject (user). Encoded in the JWT payload</td>
                    </tr>
                    <tr>
                        <td><strong>Access Token</strong></td>
                        <td>Short-lived JWT used to access protected resources (15 min in our system)</td>
                    </tr>
                    <tr>
                        <td><strong>Refresh Token</strong></td>
                        <td>Long-lived token used to obtain new access tokens (7 days in our system)</td>
                    </tr>
                    <tr>
                        <td><strong>BCrypt</strong></td>
                        <td>Password hashing algorithm designed to be slow and resistant to brute force attacks</td>
                    </tr>
                    <tr>
                        <td><strong>Salt</strong></td>
                        <td>Random data added to passwords before hashing to prevent rainbow table attacks</td>
                    </tr>
                    <tr>
                        <td><strong>Work Factor</strong></td>
                        <td>Number of BCrypt iterations (2^n). Higher = slower = more secure. We use 12 (4096 iterations)</td>
                    </tr>
                    <tr>
                        <td><strong>Rate Limiting</strong></td>
                        <td>Restricting the number of requests a client can make in a time window</td>
                    </tr>
                    <tr>
                        <td><strong>Fixed Window</strong></td>
                        <td>Rate limiting strategy that resets the counter at fixed intervals (e.g., every 60 seconds)</td>
                    </tr>
                    <tr>
                        <td><strong>Middleware</strong></td>
                        <td>Software components that process HTTP requests/responses in a pipeline</td>
                    </tr>
                    <tr>
                        <td><strong>Claims Principal</strong></td>
                        <td>ASP.NET Core representation of user identity, constructed from JWT claims</td>
                    </tr>
                    <tr>
                        <td><strong>Entity Framework Core</strong></td>
                        <td>Object-Relational Mapper (ORM) that allows working with databases using .NET objects</td>
                    </tr>
                    <tr>
                        <td><strong>Migration</strong></td>
                        <td>Version-controlled database schema change managed by Entity Framework</td>
                    </tr>
                    <tr>
                        <td><strong>Dependency Injection</strong></td>
                        <td>Design pattern where objects receive their dependencies from external sources</td>
                    </tr>
                    <tr>
                        <td><strong>Scoped Service</strong></td>
                        <td>DI lifetime where one instance is created per HTTP request</td>
                    </tr>
                    <tr>
                        <td><strong>CORS (Cross-Origin Resource Sharing)</strong></td>
                        <td>Security feature that controls which domains can access your API</td>
                    </tr>
                    <tr>
                        <td><strong>Bearer Token</strong></td>
                        <td>Token authentication scheme where access is granted to whoever "bears" (possesses) the token</td>
                    </tr>
                    <tr>
                        <td><strong>GUID (Globally Unique Identifier)</strong></td>
                        <td>128-bit number used as unique identifier (same as UUID)</td>
                    </tr>
                    <tr>
                        <td><strong>HMAC-SHA256</strong></td>
                        <td>Hash-based Message Authentication Code using SHA-256, used to sign JWTs</td>
                    </tr>
                    <tr>
                        <td><strong>Stateless Authentication</strong></td>
                        <td>Authentication system that doesn't store session data on the server</td>
                    </tr>
                </table>
            </section>
        </div>

        <footer>
            <p>SportsBetting Authentication System Documentation</p>
            <p>Built with ASP.NET Core 9.0 | PostgreSQL | JWT</p>
        </footer>
    </div>
</body>
</html>